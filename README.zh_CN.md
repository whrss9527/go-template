[English](./README.md) | 简体中文
## 项目简介：
### go-template
> Go 微服务 模板项目
> 
> 使用 [go-kratos](https://go-kratos.dev/docs/) 框架搭建的一个模板项目，用于快速搭建项目
>
> Go + Kratos + Gorm + GRPC + Docker + Jenkins + K8S
> 
功能：
- [x] 配置中心
- [x] 日志
- [x] 限流
- [x] 版本控制
- [x] GRPC
- [x] HTTP
- [x] 依赖注入
- [x] JWT
- [x] 服务间调用
- [x] 单元测试
- [x] 集成测试
- [x] CI/CD ( Docker + Jenkins + K8S )
- [x] Makefile
- [x] Swagger


## 开始使用

###### 1. 安装依赖
clone 项目到本地
```sh
$ make init 
```

---
###### 2. 启动服务
```sh
$ kratos run
```
---
###### 3. 测试
```sh
$ cd internal/biz  # go to your test dirs
$ go test -v 
```

## 项目结构
```
├── api
│    └── template_proj 
│       ├── v1
│       │   └── xxx.proto (biz, generated by make api)
│       └── errors
│            └── errors.proto (error enum, generate by make errors)
├── bin
│    └── server (generated by make build)
├── cmd
│    └── server
│         ├── main.go (main function)
│         ├── wire.go (wire)
│         └── wire_gen.go (generate by wire)
├── configs
│     └── config.yaml (config file)
├── internal
│       ├── biz
│       │    ├── biz.go (define biz ProviderSet)
│       │    ├── main_test.go (test main function)
│       │    ├── template.go (biz logic, inclouding template usecase definition)
│       │    ├── template_test.go (test case for template.go)
│       │    └── usecase_manager.go (usecase manager, using for calling each other between modules)
│       ├── data
│       │    ├── model
│       │    │    └── user.go (msyql model)
│       │    ├── mysql
│       │    │    ├── mysql.go (define mysql ProviderSet)
│       │    │    └── user.go (mysql dao)
│       │    └── redis
│       │         ├── redis.go (define redis ProviderSet)
│       │         └── user.go (redis dao)
│       ├── conf
│       │    ├── conf.proto (config struct proto)
│       │    └── conf.pb.go (generate by make config)
│       ├── pkg
│       │    ├── db
│       │    │    └── db.go 
│       │    ├── redis
│       │    │    └── redis.go
│       │    └── redis_sync
│       │         └── redis_sync.go
│       ├── server
│       │    ├── grpc.go 
│       │    ├── http.go (http config, including middleware like jwt...)
│       │    └── server.go (define server ProviderSet)
│       └── util (some utils)
├── proto
│    ├── template_proj
│    │    ├── v1
│    │    │    └── xxx.proto (orginal proto file)
│    │    └── errors
│    │         └── errors.proto (orginal error enum)
│    └── third_party (some third party proto file)
├── go.mod  
├── go.sum (generate by make init)
├── Makefile
├── Jenkinsfile
├── Dockerfile
└── openapi.yaml (swagger file, generate by make api)
```
我们将项目的结构分为三层，分别是 api、biz、model。

在 ``proto/template_proj/v1/xxx.proto`` 中定义了 api，这里的 api 是对外暴露的接口，也就是说，我们的业务逻辑是通过这里的接口暴露给外部的。

定义完成后，使用 ``make api`` 命令，会在 ``api/template_proj/v1/xxx.go`` 中生成对应的接口

然后在 ``service/xxx.go`` 中实现这些接口，这里的 ``service`` 就是我们的业务逻辑入口。


---

整体项目使用wire进行依赖注入。

在 cmd/server/wire.go 中定义了 ProviderSet，这里的 ProviderSet 就是我们的依赖注入的对象。

在 biz、mysql、redis、server 中都有 ProviderSet，这些 ProviderSet 都是在 cmd/server/wire.go 中被注入的。
>
> 依赖注入的链条：``api -> service -> biz -> data``
>
> 在 ``service/xxx.go`` 中实现接口后，我们就可以在 ``biz/template.go`` 中实现具体的业务供 ``xxx.go`` 调用。
>
> 在 ``biz/template.go`` 中实现业务逻辑后，我们就可以在 ``data/mysql/user.go`` 中实现对应的数据库操作。
>
> 在 `service` 中注入`UseCase`，`UseCase`中注入`Repo`，`Repo`中注入`DB`
---



## 接口文档：
提供API接口文档，以便其他开发人员了解该微服务的API接口。
定义好proto后，使用`make api`命令，会在项目根目录生成`openapi.yaml`文件，可以使用`swagger`工具查看接口文档，也可直接导入postman等工具查看接口文档。


## 测试: 

#### 1. Mock DB

在单元测试中，很重要的一项就是数据库的 Mock，数据库要在每次单元测试时作为一个干净的初始状态，并且每次运行速度不能太慢。

###### (1). Mysql 的 Mock

这里使用到的是 github.com/dolthub/go-mysql-server 借鉴了这位大哥的方法 [如何针对 MySQL 进行 Fake 测试](https://juejin.cn/post/7131661977310461965)

- ###### DB 的初始化
  在 db 目录下
```go
type Config struct {
   DSN             string // write data source name.
   MaxOpenConn     int    // open pool
   MaxIdleConn     int    // idle pool
   ConnMaxLifeTime int
}

var DB *gorm.DB

// InitDbConfig 初始化Db
func InitDbConfig(c *conf.Data) {
   log.Info("Initializing Mysql")
   var err error
   dsn := c.Database.Dsn
   maxIdleConns := c.Database.MaxIdleConn
   maxOpenConns := c.Database.MaxOpenConn
   connMaxLifetime := c.Database.ConnMaxLifeTime
   if DB, err = gorm.Open(mysql.Open(dsn), &gorm.Config{
      QueryFields: true,
      NamingStrategy: schema.NamingStrategy{
         //TablePrefix:   "",   // 表名前缀
         SingularTable: true, // 使用单数表名
      },
   }); err != nil {
      panic(fmt.Errorf("初始化数据库失败: %s \n", err))
   }
   sqlDB, err := DB.DB()
   if sqlDB != nil {
      sqlDB.SetMaxIdleConns(int(maxIdleConns))                               // 空闲连接数
      sqlDB.SetMaxOpenConns(int(maxOpenConns))                               // 最大连接数
      sqlDB.SetConnMaxLifetime(time.Second * time.Duration(connMaxLifetime)) // 单位：秒
   }
   log.Info("Mysql: initialization completed")
}
```

- ###### fake-mysql 的初始化和注入
  在 fake_mysql 目录下

```go
var (
   dbName    = "mydb"
   tableName = "mytable"
   address   = "localhost"
   port      = 3380
)

func InitFakeDb() {
   go func() {
      Start()
   }()
   db.InitDbConfig(&conf.Data{
      Database: &conf.Data_Database{
         Dsn:             "no_user:@tcp(localhost:3380)/mydb?timeout=2s&readTimeout=5s&writeTimeout=5s&parseTime=true&loc=Local&charset=utf8,utf8mb4",
         ShowLog:         true,
         MaxIdleConn:     10,
         MaxOpenConn:     60,
         ConnMaxLifeTime: 4000,
      },
   })
   migrateTable()
}

func Start() {
   engine := sqle.NewDefault(
      memory.NewMemoryDBProvider(
         createTestDatabase(),
         information_schema.NewInformationSchemaDatabase(),
      ))

   config := server.Config{
      Protocol: "tcp",
      Address:  fmt.Sprintf("%s:%d", address, port),
   }

   s, err := server.NewDefaultServer(config, engine)
   if err != nil {
      panic(err)
   }

   if err = s.Start(); err != nil {
      panic(err)
   }

}

func createTestDatabase() *memory.Database {
   db := memory.NewDatabase(dbName)
   db.EnablePrimaryKeyIndexes()
   return db
}

func migrateTable() {
// 生成一个user表到fake mysql中
   err := db.DB.AutoMigrate(&model.User{})
   if err != nil {
      panic(err)
   }
}
```

在单元测试开始，调用  ```InitFakeDb()``` 即可

```go
func setup() {
   fake_mysql.InitFakeDb()
}
```
---
###### (2). Redis 的 Mock
这里用到的是 [miniredis](https://github.com/alicebob/miniredis) , 与之配套的Redis Client 是  ```go-redis/redis/v8``` ，在这里调用 InitTestRedis() 注入即可

```go
// RedisClient redis 客户端  
var RedisClient *redis.Client  
  
// ErrRedisNotFound not exist in redisconst ErrRedisNotFound = redis.Nil  
  
// Config redis config
type Config struct {  
   Addr         string  
   Password     string  
   DB           int  
   MinIdleConn  int  
   DialTimeout  time.Duration  
   ReadTimeout  time.Duration  
   WriteTimeout time.Duration  
   PoolSize     int  
   PoolTimeout  time.Duration  
   // tracing switch  
   EnableTrace bool  
}  
  
// Init 实例化一个redis client  
func Init(c *conf.Data) *redis.Client {  
   RedisClient = redis.NewClient(&redis.Options{  
      Addr:         c.Redis.Addr,  
      Password:     c.Redis.Password,  
      DB:           int(c.Redis.DB),  
      MinIdleConns: int(c.Redis.MinIdleConn),  
      DialTimeout:  c.Redis.DialTimeout.AsDuration(),  
      ReadTimeout:  c.Redis.ReadTimeout.AsDuration(),  
      WriteTimeout: c.Redis.WriteTimeout.AsDuration(),  
      PoolSize:     int(c.Redis.PoolSize),  
      PoolTimeout:  c.Redis.PoolTimeout.AsDuration(),  
   })  
  
   _, err := RedisClient.Ping(context.Background()).Result()  
   if err != nil {  
      panic(err)  
   }  
  
   // hook tracing (using open telemetry)  
   if c.Redis.IsTrace {  
      RedisClient.AddHook(redisotel.NewTracingHook())  
   }  
  
   return RedisClient  
}  
  
// InitTestRedis 实例化一个可以用于单元测试的redis  
func InitTestRedis() {  
   mr, err := miniredis.Run()  
   if err != nil {  
      panic(err)  
   }  
   // 打开下面命令可以测试链接关闭的情况  
   // defer mr.Close()  
  
   RedisClient = redis.NewClient(&redis.Options{  
      Addr: mr.Addr(),  
   })  
   fmt.Println("mini redis addr:", mr.Addr())  
}
```

#### 2. 单元测试

经过对比，我选择了 [goconvey](https://github.com/smartystreets/goconvey/wiki/Documentation) 这个单元测试框架
它比原生的go testing 好用很多。goconvey还提供了很多好用的功能：

-   多层级嵌套单测
-   丰富的断言
-   清晰的单测结果
-   支持原生go test

使用
```cmd
go get github.com/smartystreets/goconvey
```


```go
func TestLoverUsecase_DailyVisit(t *testing.T) {  
   Convey("Test TestLoverUsecase_DailyVisit", t, func() {  
      // clean  
      uc := NewLoverUsecase(log.DefaultLogger, &UsecaseManager{})  
  
      Convey("ok", func() {  
         // execute  
         res1, err1 := uc.DailyVisit("user1", 3)  
         So(err1, ShouldBeNil)  
         So(res1, ShouldNotBeNil)  
         // the n (>=2)times visit，should return nil
         res2, err2 := uc.DailyVisit("user1", 3)  
         So(err2, ShouldBeNil)  
         So(res2, ShouldBeNil)  
      })  
   })  
}
```
	可以看到，函数签名和 go 原生的 test 是一致的
	测试中嵌套了两层 Convey，外层new了内层Convey所需的参数 
	内层调用了函数，对返回值进行了断言

这里的断言也可以像这样对返回值进行比较 `So(x, ShouldEqual, 2)`
或者判断长度等等 `So(len(resMap),ShouldEqual, 2)`

Convey的嵌套也可以灵活多层，可以像一棵多叉树一样扩展，足够满足业务模拟。

---

#### 3. TestMain
为所有的 case 加上一个 TestMain 作为统一入口

```go
import (  
"os"  
"testing"  
  
. "github.com/smartystreets/goconvey/convey"  
)  
  
func TestMain(m *testing.M) {  
   setup()  
   code := m.Run()  
   teardown()  
   os.Exit(code)
}
// init fake db
func setup() {  
   fake_mysql.InitFakeDb()  
   redis.InitTestRedis()
}
```

## 贡献
欢迎提交PR，或者提出issue

## 许可证
MIT License

## 作者
Gmail:  [whrss9527@gamil.com](mailto:whrss9527@gmail.com)

